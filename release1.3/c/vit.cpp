// version1.3
///////////////////////////////////////////////////////////////////
         //////                                    //////
///////////////////////////////////////////////////////////////////
///                                                             ///
/// This file is generated by Viterbi HDL Code Generator(VHCG)  ///
/// which is written by Mike Johnson at OpenCores.org  and      ///
/// distributed under GPL license.                              ///
///                                                             ///
/// If you have any advice,                                     ///
/// please email to jhonson.zhu@gmail.com                       ///
///                                                             ///
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////




// B=1, symbol_num=2, W=4, V=1, U=1
// para_polys=91 121
// Support Direct Traceback, Synchronous Ram


#include <stdio.h>
#include<iostream>
#include<vector>

const int $para_state_num=64;	//8
const int $para_symbol_num=2;	//2
const int $para_conv_m=6;		//3
const int $para_path_num=2;	//2
const int  patn_len=6;
const int $V=1;				//2**$V is the path num
using namespace std;

int main()
{
	int pattern[patn_len]={1, 1, 1, 1, 1, 1};
	int cnt=0, patn_cnt=0;
	unsigned char symbol;
	vector<unsigned char> m($para_conv_m+1);
	vector<int> decs($para_state_num);
	vector<int> symbols($para_symbol_num);
	vector<int> bm($para_path_num); //////////////////////////////////////////
	vector<int> sm1($para_state_num),sm2($para_state_num);
	vector<int> *old_sm=&sm1, *new_sm=&sm2, *tmp_sm;
		
// for some things, the m[i] is newer than m[j], if i>j; because when I write the gen_poly function, I think bit is from high bits move to low bits and new bit commes into m from high bits. 
	
	while(!cin.eof()&&cin>>symbol){
		if(!(symbol=='0'||symbol=='1')) continue;
		symbol-='0';
		symbols[cnt]=symbol;
		// prepare enough symbols for decode
		cnt++;
		if(cnt==$para_symbol_num){
			cnt=0;
			// for each state we generate a dec
			for(int index=0;index<$para_state_num;index++){
				int state=index;
				{int tmp;
				tmp=state>>$V;
				state<<=($para_conv_m-$V);
				state|=tmp;}
				// for each path into this state;
				for(int path=0;path<$para_path_num;path++){
					// now just support $para_path_num=2
					int old_state;
					old_state=state<<$V;
					old_state|=path;
					old_state&=63;
					int v_shift=0x01;
					m[0]=path;					///////////////////////////////////////////
					for(int i=$V;i<$para_conv_m+$V;i++,v_shift<<=1)
					{
						m[i]=(state&v_shift)==0? 0 : 1;   
					}
					bm[path]=(*old_sm)[old_state];
						if(pattern[patn_cnt+0])
							bm[path]+=symbols[0]^m[6]^m[4]^m[3]^m[1]^m[0];  // compare symbol0
						if(pattern[patn_cnt+1])
							bm[path]+=symbols[1]^m[6]^m[5]^m[4]^m[3]^m[0];  // compare symbol1
				}
				if(bm[0]<bm[1]){					////////////////////////////////////////////////
					decs[index]=0;
					(*new_sm)[state]=bm[0];
				}
				else{
					decs[index]=1;
					(*new_sm)[state]=bm[1];
				}
			}
			// print out decs for debug
			for(int i=0;i<$para_state_num;i++){
				if((i%32)==0){
					cout<<"\n";
				}
				cout<<decs[i];
			}
			cout<<"\n";
			tmp_sm=new_sm;
			new_sm=old_sm;
			old_sm=tmp_sm;
			patn_cnt+=$para_symbol_num;	
			patn_cnt%=patn_len;
		}
	}
	return 0;
}
